<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
<script>
// 继续抽取   公共的部分放到原型上
// const Person1 = {
//   eyes: 2,
//   head: 1
// }
// const Person2 = {
//   eyes: 2,
//   head: 1
// }
// 构造函数  new 出来的对象 结构一样，但是对象不一样
function Person () {
  this.eyes = 2
  this.head = 1
}

// console.log(new Person)
// 女人  构造函数   继承  想要 继承 Person
function Woman () {

}

// Woman 通过原型来继承 Person
// 父构造函数（父类）   子构造函数（子类）
// 子类的原型 =  new 父类
// Woman.prototype =  Person 【出错】：若同时有 Man.prototype = Person 则会导致 Woman.prototype.baby 同时添加给Man一个baby()方法
console.log(Person)
//【解决方法】 抽取构造函数，给原型对象指定不同的对象: new Person()
Woman.prototype = new Person()   // {eyes: 2, head: 1}
// 指回原来的构造函数  【注意】: 这里由于重新给Woman.prototype赋值了 ，因此constructor属性不再指向Person了,而是Woman
Woman.prototype.constructor = Woman

// 给女人添加一个方法  生孩子
Woman.prototype.baby = function () {
  console.log('宝贝')
}
const red = new Woman()
console.log(red)
console.log(Woman.prototype)
console.log(Woman.prototype.constructor)

// 男人 构造函数  继承  想要 继承 Person
function Man () {

}

// 通过 原型继承 Person
Man.prototype = new Person()
Man.prototype.constructor = Man
const pink = new Man()
console.log(pink)
</script>
</body>

</html>
